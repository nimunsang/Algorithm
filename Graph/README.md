# GRAPH

### Bellman-Ford vs Dijkstra vs Floyd-Warshall   

* 공통점 : 다이나믹 프로그래밍을 이용

#### Bellman-Ford

* **하나의 정점에서 다른 모든 정점**으로의 최단거리를 구하는 알고리즘

* (N-1) 번의 매 단계마다 모든 간선을 전부 확인하면서 모든 노드간의 최단 거리를 구해 나간다.

* Dijkstra 알고리즘 에서의 최적의 해를 항상 포함한다.

* 음수 간선이 있어도 최적의 해를 구할 수 있다.

* 음의 사이클을 감지할 수 있다.

* 시간 복잡도 : **O(VE)**

#### Dijkstra

* **하나의 정점에서 다른 모든 정점**으로의 최단거리를 구하는 알고리즘

* 방문하지 않은 노드 중에서 최단 거리가 가장 가까운 노드만을 방문한다.

* 음수 간선이 있다면 최적의 해를 구할 수 없다.

* 시간 복잡도 : **O(ElogV)**   <- 우선순위 큐 사용

### Floyd-Warshall

* **모든 정점에서 다른 모든 정점**으로의 최단거리를 구하는 알고리즘

* 거쳐가는 정점을 기준으로 최단거리를 구한다.

* 음의 간선도 사용 가능하지만, 음의 사이클은 없어야한다.

* 시간 복잡도 : **O(V^3)**









### BFS ( Breadth-First Search )

* 시작 정점으로부터 **가까운 정점을 먼저 방문**하고, 멀리 떨어져 있는 정점을 나중에 방문하는 순회 방법이다.

* 두 노드 사이의 `최단 경로`를 찾고 싶을 때 이 방법을 사용한다.

* 어떤 노드를 방문했었는지 **방문 여부를 반드시 검사**해야 한다.
(방문한 노드를 재방문 하지 않도록 하기 위함)

* FIFO를 원칙으로 탐색하므로, `<Queue>`를 사용한다.

#### **시간 복잡도**

* 인접 리스트로 표현된 그래프 : **O(N+E)**
* 인접 행렬로 표현된 그래프 : **O(N^2)**
* 그래프 내에 **적은 숫자의 간선을 가지는 희소 그래프(Sparse Graph)의 경우**, 인접 리스트를 사용하면 유리하다.

#### **장점** 

* 출발노드로부터 목표노드까지 **최단 길이 경로**를 보장한다.

#### **단점** 

* 큐에 다음에 탐색할 정점들을 저장해야 하므로, **많은 기억 공간**을 필요로 한다.
* 해가 존재하지 않는 유한 그래프의 경우, 모든 그래프를 탐색한 후에 실패로 끝난다.

---