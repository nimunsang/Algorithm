# BFS ( Breadth-First Search )

### [골드3] #6087 (https://www.acmicpc.net/problem/6087)

> board에서 시작점부터 끝점까지 경로 중 가장 적게 90도로 꺾이는 경로에서 꺾인 횟수를 구하는 문제이다.

* **문제 해결 알고리즘 : ```BFS```**

--

### [골드4] #1963 (https://www.acmicpc.net/problem/1963)

> 4자리의 어떤 소수에서 다른 소수까지 가는 최단 경로를 구하는데, 한 번에 한 자릿수밖에 못바꾼다. 중간의 바뀐 숫자도 소수여야 한다. 

* **문제 해결 알고리즘 : ```BFS```, ```에라토스테네스의 체```**

--

### [골드4] #13913 (https://www.acmicpc.net/problem/13913)

> 한 숫자에서 다른 숫자까지 가는 최단 경로의 길이를 구하고, 그 경로를 구하는 문제이다( x+1, x-1, x*2 사용)

* **문제 해결 알고리즘 : ```BFS```, **
* 경로를 구할 때, **경로를 queue에 넣는 것이 아니라**, 다른 dictionary 혹은 list를 초기화하고, 방문 정점의 부모만을 저장하여 track한다.

--

### [골드5] #2589 (https://www.acmicpc.net/problem/2589)

> board에서 bfs를 써서 시작점부터 끝점까지 최대 길이를 구하는 문제이다.

* **문제 해결 알고리즘 : ```BFS```, ```brute-force```**
* board의 크기가 50*50 이고, 시간제한이 1초이면, 정점이 2500개라고 생각했을 때, 
* 최악의 경우 O(V^2) 즉 2500*2500 = 6250000이라서, 브루트포스로도 충분하다..
* BFS를 돌릴 때, while q 바로 밑 에서 visited처리를 하지말고, if문 안에서 visited처리를 하자(다음 방문 노드를 처리하자)

---

### [골드5] #5014 (https://www.acmicpc.net/problem/5014)

> 엘리베이터를 타고 특정 층으로 갈 수 있는 최소 경로를 구하는 BFS 문제이다.

* **문제 해결 알고리즘 : ```BFS```**

---

### [실버1] #9205 (https://www.acmicpc.net/problem/9205)

> 간단한 조건을 가진 BFS 문제이다.
 
* **문제 해결 알고리즘 : ```BFS```**
* 좌표를 생성할 때, 범위 체크를 잘하자

---

### [실버2] #5567 (https://www.acmicpc.net/problem/5567)

> 친구의 친구 관계를 따지는 문제이다.

* **문제 해결 알고리즘 : ```BFS```**

---

