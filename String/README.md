# String

---

### [실버3] #17413 (https://www.acmicpc.net/problem/17413)

>간단한 조건을 만족하는 단어 뒤집기 문제였다. 

* **문제 해결 알고리즘 : ```문자열```**


---

### [골드4] #5052 (https://www.acmicpc.net/problem/5052)

> 주어진 문자열들 중에서, 어떤 문자열이, 다른 문자열의 Substring인 것이 존재하는지 찾는 문제였다.

* **문제 해결 알고리즘 : ```분할 정복```, ```counting sort```**

주어진 조건에서, ```O(nlogn)```안에 해결해야 하므로, ```LCP배열```과 ```정렬``` 알고리즘이 떠올랐지만, 정확히 푸는 방법을 몰라서,

분할 정복과 counting sort를 혼합하여 문제를 해결하였다.

LCP배열을 만드는 기초는 정렬이었고, **정렬된 문자열들에서 바로 뒤 문자열만 확인하면 된다는 사실**을 다시 알게 되었다.

또, ```트라이``` 라는 자료구조가 있다는 사실을 알게 되었다.

이런 문제를 다시 풀게 된다면, 정렬 후, 바로 뒤 문자열만을 확인할 것이다.

---

### [실버3] #14425 (https://www.acmicpc.net/problem/14425)

>어떤 두 리스트가 주어졌을 때, 두 리스트의 공통되는 원소의 개수를 찾는 문제이다. (두 리스트의 크기는 10000 이하)

* **실패한 알고리즘 : ```정렬```, ```이분탐색```**

* **문제 해결 알고리즘 : ```집합(set)```**

두 리스트를 각각 ```정렬```(O(nlog n))하고, 한 리스트의 원소들을 돌면서, 

다른 대상 리스트를 ```이분 탐색```(O(log n))하는 방식을 생각했다. 이렇게 한다면, 

두 리스트를 정렬 하는데 걸리는 시간 (O(nlogn))

원소의 개수 n개에 대하여 이분탐색 하는 데 걸리는 시간 (n * O(logn)) = (O(nlogn))

합하여, `n<=10000` 이므로, `O(nlogn)`에 문제를 해결할 수 있을 줄 알았다. 

하지만, 문제에서 문자열의 길이에 대한 언급이 없었으므로, 잘못된 풀이 방식이다.   
(예를 들어, 문자열의 길이가 n이라면, O(n^2 * logn) 의 시간이 걸릴 것이다.)

그러므로, 파이썬의 `set()`을 사용하였는데, 이유는 다음과 같다.

* list에서의 x in list 연산의 평균 시간 복잡도 : **O(n)**
* set에서의 x in set 연산의 평균 시간 복잡도 : **O(1)**

#### 파이썬에서의 set이 효율적일 수 있는 이유 ? = `해시 테이블`
(`해시 테이블`에 관한 설명은, 'Data Structure' 폴더에 자세히 하겠다)

즉, 문제는 단순히 리스트의 원소들을 돌면서, x in set 연산을 하게 된다면, O(n) 의 시간에 해결될 것이다.

---



