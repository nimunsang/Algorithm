# Divide And Conquer

## 분할 정복이란?

* 한 문제를 둘 이상의 부분 문제로 나누어 해결하고, 이를 합쳐 원래 문제를 해결하는 기법


* 분할 정복의 단계
  1. **분할(Divide)** : 원래 문제를 분할하여 더 작은 하위 문제들로 나눈다.
  2. **정복(Conquer)** : 하위 문제 각각을 재귀적으로 해결한다.     
   (정복 과정에서 더 이상 분할하지 않고 곧장 풀 수 있는 매우 작은 문제를 기저 사례(Base case)라 한다)
  3. **병합(Merge)** : 하위 문제들의 답을 합쳐서 원래 문제를 해결한다.
  

* 일반적인 재귀 호출 vs 분할 정복    
  - 분할 정복이 일반적인 재귀 호출과 다른 점은, 문제를 거의 같은 크기의 부분 문제로 나누는 것이다.
  
  
* 분할 정복의 장점
  - 보통, 분할 정복의 경우 작은 문제로 분할함으로써 같은 작업을 더 빠르게 처리할 수 있게 해준다.
  - 어려운 문제를 간단한 작은 문제로 나누어 풀 수 있다.


* 분할 정복의 예시
  - 수열의 빠른 합
  - 행렬의 빠른 제곱
  - **Merge Sort, Quick Sort**
     - 두 정렬 모두, 분할 정복을 기반으로 해서 만들어졌다.
     - 차이점은, 시간이 많이 걸리는 작업을 분할 단계에서 하느냐, 병합 단계에서 하느냐가 다르다.


### Merge Sort vs Quick Sort

* Merge Sort
  * 전체 수행 시간은 병합 과정에 의해 지배된다.
  * O(n)이 걸리는 과정을 재귀 호출 후에 진행(병합 과정)
  * 문제의 수는 항상 절반으로 나눠지므로, O(log N)
  * 시간 복잡도 : 항상 O(NlogN)으로 일정


* Quick Sort
  * 전체 수행 시간은 두개 부분 문제로 나누는 파티션 과정에 의해 지배된다.
  * 분할된 두 부분 문제가 비슷한 크기로 나눠진다는 보장이 없기 때문에, 좋은 pivot을 설정하는 것이 중요하다.
  * O(n)이 걸리는 과정을 재귀 호출 전에 진행(분할 과정)
  * 문제의 수가 항상 절반으로 나뉜다는 보장이 없기 때문에, 필요한 단계 수를 정확히 계산하기 힘들다.
  * 최악의 경우 N, 평균적인 경우 log N 만큼의 단계가 필요하다.
  * 시간 복잡도
    * 최악 : O(N^2)
    * 평균 : O(NlogN)
    
---

### [골드4] #10830 (https://www.acmicpc.net/problem/10830)

> 행렬의 N제곱을 구하는 문제다. 단, N은 100,000,000,000 이하 

* **문제 해결 알고리즘 : ```Divide And Conquer```**
* Comment : 분할 정복을 이용한 거듭제곱 문제이다. N의 범위를 확인하고, log(N)에 해결해야 하는 문제였다. 행렬의 곱셈 공식도 다시 

---

### [실버2] #17829 (https://www.acmicpc.net/problem/17829)

> K-NN 문제를 분할정복으로 해결하는 문제이다.

* **문제 해결 알고리즘 : ```Divide And Conquer```**

---