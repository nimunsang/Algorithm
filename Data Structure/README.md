# Data Structure (자료 구조)

## 이진 탐색 트리 (Binary Search Tree)

* 이진 탐색과 연결 리스트를 결합한 자료구조    
* 이진 탐색의 효율적인 탐색 능력과, 빈번한 자료 입력, 삭제가 가능
* 각 노드의 왼쪽 서브트리에는 해당 노드의 값보다 작은 값을 지닌 노드들로 이루어짐
* 각 노드의 오른쪽 서브트리에는 해당 노드의 값보다 큰 값을 지닌 노드들로 이루어짐
* 중복된 노드가 없어야 함
* 왼쪽 서브트리, 오른쪽 서브트리 또한 이진 탐색 트리임    
* 이진 탐색 트리를 중위순회(inorder)한다면, 이진 탐색 트리 내의 모든 값들을 정렬된 순서대로 읽을 수 있다.


원소 **삽입** 시 시간 복잡도 : **O(h)**   
원소 **삭제** 시 시간 복잡도 : **O(h)**   
원소 **검색** 시 시간 복잡도 : **O(h)**   
(h : 트리의 높이)

한계점 : 이진탐색트리의 검색, 삽입, 삭제 연산은 모두 **O(h)**이다.     
즉, 트리의 높이에 의해 수행 시간이 결정된다.    
만약, 트리의 균형이 맞지 않다면 (극단적 예로, 노드의 수가 n개인데 높이가 n이라면)   
다소 비효율적일 수 있다.      
이 때문에, 트리의 입력, 삭제 단계에 트리 전체의 균형을 맞추는 이진탐색트리의 일종인 **AVL Tree**가 제안되었다.

---

## 힙(Heap)

* 완전 이진 트리의 일종인 자료구조    
완전 이진 트리 : 마지막을 제외한 모든 노드의 자식들이 꽉 채워진 이진 트리
* 우선순위 큐를 위하여 만들어진 자료구조
* 여러 개의 값들 중에서 최솟값/최댓값을 빠르게 찾아내도록 만들어짐
* 이진 탐색 트리와 달리 중복 값 허용

원소 **삽입** 시 시간 복잡도 : **O(logN)**   
(말단 노드에 원소 삽입 후, heapify 과정)   
원소 **삭제** 시 시간 복잡도 : **O(logN)**    
(루트 노드 삭제 후, 말단 노드를 루트 노드로 설정 후, heapify 과정)   
모두 **트리의 높이**만큼 작업이 이루어지므로, O(logN) 의 시간이 소요된다.    

(참고) <a href=../Sort>Heap Sort</a>

---

## 스택(Stack)

* 한 쪽 끝에서만 자료를 넣고 뺄 수 있는 LIFO(Last In First Out)형식의 자료구조

---

## 큐(Queue)

* 먼저 들어온 자료가 먼저 나가는 FIFO(First In First Out)형식의 자료구조

---

### [골드3] #2812(https://www.acmicpc.net/problem/2812)

> 특정한 조건에 의해, 스택에 push할지, pop할지 선택하는 문제였다.

* **문제 해결 알고리즘 : `스택`, `그리디 알고리즘`**

comment : 그리디 알고리즘을 사용하는 문제에 스택을 사용하는 경우가 많은 것 같다.

---

### [골드5] #1715(https://www.acmicpc.net/problem/1715)

> 최소 힙을 이용하여 그리디 알고리즘으로 풀어내는 문제였다. 

* **문제 해결 알고리즘 : `그리디 알고리즘`, `최소 힙`**

Comment : heapq.heapify (배열을 힙으로 만드는) 시간 복잡도 : O(NlogN)

---


### [실버1] #9934(https://www.acmicpc.net/problem/9934)

> 완전 이진 트리의 순회 순서를 묻는 문제였다.

* **문제 해결 알고리즘 : `재귀`**

Comment : 트리의 순회 방식에 대해 더 깊이 공부해야 할 필요가 있다.

---
