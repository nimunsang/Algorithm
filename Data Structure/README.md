# Data Structure (자료 구조)

## 이진 탐색 트리 (Binary Search Tree)

* **이진 탐색과 연결 리스트를 결합**한 자료구조    
* **이진 탐색의 효율적인 탐색 능력과, 연결 리스트의 빈번한 자료 입력, 삭제가 가능**
* 각 노드의 왼쪽 서브트리에는 해당 노드의 값보다 작은 값을 지닌 노드들로 이루어짐
* 각 노드의 오른쪽 서브트리에는 해당 노드의 값보다 큰 값을 지닌 노드들로 이루어짐
* **중복된 노드가 없어야 함**
* 왼쪽 서브트리, 오른쪽 서브트리 또한 이진 탐색 트리임    
* 이진 탐색 트리를 **중위순회(inorder)** 한다면, 이진 탐색 트리 내의 모든 값들을 정렬된 순서대로 읽을 수 있다.


원소 **삽입** 시 시간 복잡도 : **O(h)**   
원소 **삭제** 시 시간 복잡도 : **O(h)**   
원소 **검색** 시 시간 복잡도 : **O(h)**   
( h : 트리의 높이 )

* **한계점** : 이진탐색트리의 검색, 삽입, 삭제 연산은 모두 **O(h)** 으로, **트리의 높이**에 의해 수행 시간이 결정된다.    
만약, 트리의 균형이 맞지 않다면 (극단적 예로, 노드의 수가 n개인데 높이가 n이라면), 비효율적일 수 있다.      
이 때문에, 트리의 입력, 삭제 단계에 **트리 전체의 균형을 맞추는** 이진탐색트리의 일종인 **AVL Tree**가 제안되었다.

---

## AVL Tree

* 스스로 균형을 잡는 이진 탐색 트리
* 한쪽으로 치우친 편향 이진트리를 방지하고자 사용
* 왼쪽, 오른쪽 서브 트리의 높이 차이가 최대 1이다.
* 어떤 시점에서 높이 차이가 1보다 커지면 회전(rotation)을 통해 균형을 잡아 높이 차이를 줄인다.
* 높이를 logN으로 유지하기 때문에, 삽입, 검색, 삭제의 시간 복잡도는 O(logN)이다.

## 힙(Heap)

* **완전 이진 트리의 일종**인 자료구조
  * 완전 이진 트리 : 마지막을 제외한 모든 노드의 자식들이 꽉 채워진 이진 트리
* 여러 개의 값들 중에서 최솟값/최댓값을 빠르게 찾아내도록 만들어짐
* 이진 탐색 트리와 달리 중복 값 허용


* 원소 **삽입** 시 시간 복잡도 : **O(logN)**   
  * (말단 노드에 원소 삽입 후, heapify 과정)   
* 원소 **삭제** 시 시간 복잡도 : **O(logN)**    
  * (루트 노드 삭제 후, 말단 노드를 루트 노드로 설정 후, heapify 과정)   
* 모두 **트리의 높이**만큼 작업이 이루어지므로, **O(logN)** 의 시간이 소요된다.   
* `heapq.heapify()`의 시간 복잡도 : **O(N)**


* 사용 사례
  * 우선순위 큐
  * Dijkstra
  * Heap Sort
  
---

## 스택(Stack)

* 한 쪽 끝에서만 자료를 넣고 뺄 수 있는 LIFO(Last In First Out)형식의 자료구조

---

## 큐(Queue)

* 먼저 들어온 자료가 먼저 나가는 FIFO(First In First Out)형식의 자료구조

---

## 연결리스트(Linked List)

* 각 노드가 데이터와 포인터를 가지고 한 줄로 연결되어 있는 방식으로 데이터를 저장하는 자료구조
* 다른 추상 자료형(Abstract Data Type)을 구현할 때 기반이 되는 기초 선형 자료구조
* **배열 vs 연결리스트**
  * **메모리 주소**
    * 배열 : 물리적인 메모리 주소가 연속적
    * 연결리스트 : 물리적인 메모리 주소가 불연속적
  * **삽입/삭제**
    * 배열 : O(n)
    * 연결리스트 : O(n) ( 단, 삽입/삭제 자체의 시간은 O(1)이고, index에 접근하는 시간이 O(n) )
  * **원소 접근**
    * 배열 : O(1)
    * 연결리스트 : O(n)

---

## 분리 집합(Disjoint Set)

* 공통 원소가 없는 서로소 집합들로 나눠진 원소들에 대한 정보를 저장하는 자료구조
* **Union-Find** 기법으로 구현 가능하다


* ### Union-Find Algorithm
  * Disjoint Set을 표현할 때 사용하는 알고리즘으로, 트리 구조를 활용
  * 노드들 중에 연결된 노드를 찾거나, 노드들을 서로 연결할 때 사용
  * 적용
    * 네트워크 연결 구조
    * Lowest Common Ancestor
    * Kruskal Algorithm
* 최적화 
  * Union 순서에 따라, 최악의 경우 링크드 리스트와 같은 형태가 될 수 있다.
  * 이 경우, O(N)이 될 수 있으므로, **Union-by-rank**, **Path Compression** 기법 사용
  
  #### Union-by-rank
    * 각 트리에 대해 높이(rank)를 기억한다.
    * Union시 두 트리의 높이(rank)가 다르면, 높이가 작은 트리를 높이가 큰 트리에 붙인다.
    * 높이가 h-1인 두 개의 트리를 합칠 때는, 한 쪽의 트리 높이를 1 증가시키고, 다른 트리를 해당 트리에 붙인다.
    * Union-by-rank를 통해, **O(logN)** 으로 Union-Find 연산 가능
  #### Path-Compression (경로 압축)
    * Find를 실행한 노드에서 거쳐간 노드를 루트에 직접 연결하는 기법
    * Find를 실행한 노드는 이후부터는 루트 노드를 한번에 알 수 있다.
    
    ```python
  
    def find(x):
        if parent[x] != x:
            parent[x] = find(parent[x])  # 메모이제이션
        return parent[x]
  
    def union(node_a, node_b):
        root1 = find(node_a)
        root2 = find(node_b)
        
        if rank[root1] > rank[root2]:
            parent[root2] = root1
        else:
            parent[root1] = root2
            if rank[root1] == rank[root2]:
               rank[root2] += 1
    
    def make_set(node):
        parent[node] = node
        rank[node] = 0
  
    ```

---

### [골드1] #11003(https://www.acmicpc.net/problem/11003)

> 주어진 list를 순회하면서, 특정 범위만큼의 부분 list중 최솟값들을 출력하는 문제이다.

* **문제 해결 알고리즘 : `덱`**
* 덱을 계속 오름차순으로 유지하는 것이 핵심인 문제였다.

---

### [골드3] #17299(https://www.acmicpc.net/problem/17299)

> 특정한 조건에 의해, 스택에 push할지, pop할지 선택하는 문제였다.

* **문제 해결 알고리즘 : `스택`**
* list의 크기가 클 때(100만), stack을 활용하는 문제가 많은 것 같다.

---

### [골드3] #2812(https://www.acmicpc.net/problem/2812)

> 특정한 조건에 의해, 스택에 push할지, pop할지 선택하는 문제였다.

* **문제 해결 알고리즘 : `스택`, `그리디 알고리즘`**
* 그리디 알고리즘을 사용하는 문제에 스택을 사용하는 경우가 많은 것 같다.

---

### [골드4] #1939(https://www.acmicpc.net/problem/1939)

> 가중치 그래프에서 시작점부터 끝점까지 가능한 경로들 중에, 경로 상 가중치의 최소값 중, 최대인 값을 찾는 문제이다.

* **문제 해결 알고리즘 : `Union-Find`**
* 가중치의 내림차순으로 우선 정보를 정렬하고, 노드를 연결해준다.
* 시작노드의 parent와 끝노드의 parent가 같다면, 그래프가 이어질 수 있는 것이므로, break하고 cost를 return한다.

---

### [골드4] #1043(https://www.acmicpc.net/problem/1043)

> 노드들이 특정한 그룹에 속하는지 아닌지 판단하는 문제이다.

* **문제 해결 알고리즘 : `set`**
* set의 '&' 연산으로 매우 쉽게 해결 가능한 문제였다.

---

### [골드4] #1976(https://www.acmicpc.net/problem/1976)

> 노드 간의 연결 관계가 주어졌을 때, 분리 집합 여부를 확인하는 문제이다.

* **문제 해결 알고리즘 : `BFS`, `UNION-FIND`**
* 첫 번째 풀었을 때, BFS로 간단하게 한 정점과 연결된 모든 정점들을 구해서, 포함 관계를 살펴보았다.
* 다른 사람들의 풀이로는, UNION-FIND를 통해, 분리 집합의 여부를 살펴보았다.

---

### [골드5] #1715(https://www.acmicpc.net/problem/1715)

> 최소 힙을 이용하여 그리디 알고리즘으로 풀어내는 문제였다. 

* **문제 해결 알고리즘 : `그리디 알고리즘`, `최소 힙`**
* heapq.heapify (배열을 힙으로 만드는) 시간 복잡도 : O(NlogN)

---

### [실버1] #9934(https://www.acmicpc.net/problem/9934)

> 완전 이진 트리의 순회 순서를 묻는 문제였다.

* **문제 해결 알고리즘 : `재귀`**
* 트리의 순회 방식에 대해 더 깊이 공부해야 할 필요가 있다.

---

### [실버2] #5397(https://www.acmicpc.net/problem/5397)

> 키보드 입력의 기본 동작과 결과문을 구하는 문제이다. ('<', '>', '-' 구현)

* **문제 해결 알고리즘 : `스택`**

* 입력 문자열의 길이('<', '>', '-'포함)가 1,000,000까지 였고, 시간제한이 1초이다.
* 일반적인 pop(), insert()로는, O(n)의 시간 복잡도 때문에, 시간 초과가 발생했다.
* LinkedList의 삽입/삭제 소요시간이 O(1)이라는 기억이 나서, 구현을 하였지만, 사실상 O(n)이다.
* 구현을 해서 알겠지만, index를 찾는데 O(n)의 시간이 걸리기 때문이다.
* 즉, stack의 pop과 append만을 사용하는 것이 핵심인 문제였다.
