# Data Structure (자료 구조)

## 이진 탐색 트리 (Binary Search Tree)

* 이진 탐색과 연결 리스트를 결합한 자료구조    
* 이진 탐색의 효율적인 탐색 능력과, 빈번한 자료 입력, 삭제가 가능
* 각 노드의 왼쪽 서브트리에는 해당 노드의 값보다 작은 값을 지닌 노드들로 이루어짐
* 각 노드의 오른쪽 서브트리에는 해당 노드의 값보다 큰 값을 지닌 노드들로 이루어짐
* 중복된 노드가 없어야 함
* 왼쪽 서브트리, 오른쪽 서브트리 또한 이진 탐색 트리임    
* 이진 탐색 트리를 중위순회(inorder)한다면, 이진 탐색 트리 내의 모든 값들을 정렬된 순서대로 읽을 수 있다.


원소 **삽입** 시 시간 복잡도 : **O(h)**   
원소 **삭제** 시 시간 복잡도 : **O(h)**   
원소 **검색** 시 시간 복잡도 : **O(h)**   
(h : 트리의 높이)

한계점 : 이진탐색트리의 검색, 삽입, 삭제 연산은 모두 **O(h)**이다.     
즉, 트리의 높이에 의해 수행 시간이 결정된다.    
만약, 트리의 균형이 맞지 않다면 (극단적 예로, 노드의 수가 n개인데 높이가 n이라면)   
다소 비효율적일 수 있다.      
이 때문에, 트리의 입력, 삭제 단계에 트리 전체의 균형을 맞추는 이진탐색트리의 일종인 **AVL Tree**가 제안되었다.

---

## 힙(Heap)

* 완전 이진 트리의 일종인 자료구조    
완전 이진 트리 : 마지막을 제외한 모든 노드의 자식들이 꽉 채워진 이진 트리
* 우선순위 큐를 위하여 만들어진 자료구조
* 여러 개의 값들 중에서 최솟값/최댓값을 빠르게 찾아내도록 만들어짐
* 이진 탐색 트리와 달리 중복 값 허용

원소 **삽입** 시 시간 복잡도 : **O(logN)**   
(말단 노드에 원소 삽입 후, heapify 과정)   
원소 **삭제** 시 시간 복잡도 : **O(logN)**    
(루트 노드 삭제 후, 말단 노드를 루트 노드로 설정 후, heapify 과정)   
모두 **트리의 높이**만큼 작업이 이루어지므로, O(logN) 의 시간이 소요된다.    

(참고) <a href=../Sort>Heap Sort</a>

---

## 스택(Stack)

* 한 쪽 끝에서만 자료를 넣고 뺄 수 있는 LIFO(Last In First Out)형식의 자료구조

---

## 큐(Queue)

* 먼저 들어온 자료가 먼저 나가는 FIFO(First In First Out)형식의 자료구조

---

## 연결리스트(Linked List)

* 다른 추상 자료형(Abstract Data Type)을 구현할 때 기반이 되는 기초 선형 자료구조
* 각 노드가 데이터와 포인터를 가지고 한 줄로 연결되어 있는 방식으로 데이터를 저장한다.
* 배열 vs 연결리스트
  * 배열은 물리적인 메모리 주소가 연속적
  * 연결리스트는 물리적인 메모리 주소가 연속적이지 않다
  * 배열은 삽입/삭제가 O(n)의 시간이 걸린다
  * 연결리스트는 삽입/삭제가 O(1)의 시간이 걸린다(x)
  * 연결리스트는 삽입/삭제 시, 결국 그 index에 접근해야하는 시간이 O(n)이므로, O(n)이다.
  * 배열은 각 원소에 인덱스로 O(1)의 시간이 걸린다
  * 연결리스트는 O(n)의 시간이 걸린다

---

## 분리 집합(Disjoint Set)

* 공통 원소가 없는 서로소 집합들로 나눠진 원소들에 대한 정보를 저장하는 자료구조
* Union-Find 기법으로 구현 가능하다
* 적용
  * 네트워크 연결 구조
  * Lowest Common Ancestor
  * Kruskal Algorithm
* Union-Find의 최적화
  * Path-Compression (경로 압축)
    *     def find(x):
              if parent[x] != x:
                  parent[x] = find(parent[x])  # 메모이제이션
              return parent[x]

---

### [골드3] #2812(https://www.acmicpc.net/problem/2812)

> 특정한 조건에 의해, 스택에 push할지, pop할지 선택하는 문제였다.

* **문제 해결 알고리즘 : `스택`, `그리디 알고리즘`**
* 그리디 알고리즘을 사용하는 문제에 스택을 사용하는 경우가 많은 것 같다.

---

### [골드4] #1939(https://www.acmicpc.net/problem/1939)

> 가중치 그래프에서 시작점부터 끝점까지 가능한 경로들 중에, 경로 상 가중치의 최소값 중, 최대인 값을 찾는 문제이다.

* **문제 해결 알고리즘 : `Union-Find`**
* 가중치의 내림차순으로 우선 정보를 정렬하고, 노드를 연결해준다.
* 시작노드의 parent와 끝노드의 parent가 같다면, 그래프가 이어질 수 있는 것이므로, break하고 cost를 return한다.

---

### [골드4] #1043(https://www.acmicpc.net/problem/1043)

> 노드들이 특정한 그룹에 속하는지 아닌지 판단하는 문제이다.

* **문제 해결 알고리즘 : `set`**
* set의 '&' 연산으로 매우 쉽게 해결 가능한 문제였다.

---

### [골드4] #1976(https://www.acmicpc.net/problem/1976)

> 노드 간의 연결 관계가 주어졌을 때, 분리 집합 여부를 확인하는 문제이다.

* **문제 해결 알고리즘 : `BFS`, `UNION-FIND`**
* 첫 번째 풀었을 때, BFS로 간단하게 한 정점과 연결된 모든 정점들을 구해서, 포함 관계를 살펴보았다.
* 다른 사람들의 풀이로는, UNION-FIND를 통해, 분리 집합의 여부를 살펴보았다.

---

### [골드5] #1715(https://www.acmicpc.net/problem/1715)

> 최소 힙을 이용하여 그리디 알고리즘으로 풀어내는 문제였다. 

* **문제 해결 알고리즘 : `그리디 알고리즘`, `최소 힙`**
* heapq.heapify (배열을 힙으로 만드는) 시간 복잡도 : O(NlogN)

---


### [실버1] #9934(https://www.acmicpc.net/problem/9934)

> 완전 이진 트리의 순회 순서를 묻는 문제였다.

* **문제 해결 알고리즘 : `재귀`**
* 트리의 순회 방식에 대해 더 깊이 공부해야 할 필요가 있다.

---

### [실버2] #5397(https://www.acmicpc.net/problem/5397)

> 키보드 입력의 기본 동작과 결과문을 구하는 문제이다. ('<', '>', '-' 구현)

* **문제 해결 알고리즘 : `스택`**

* 입력 문자열의 길이('<', '>', '-'포함)가 1,000,000까지 였고, 시간제한이 1초이다.
* 일반적인 pop(), insert()로는, O(n)의 시간 복잡도 때문에, 시간 초과가 발생했다.
* LinkedList의 삽입/삭제 소요시간이 O(1)이라는 기억이 나서, 구현을 하였지만, 사실상 O(n)이다.
* 구현을 해서 알겠지만, index를 찾는데 O(n)의 시간이 걸리기 때문이다.
* 즉, stack의 pop과 append만을 사용하는 것이 핵심인 문제였다.
